import { useState, useEffect, useCallback } from 'react';
import { supabase, isSupabaseConfigured } from '../lib/supabase';
import { Question } from '../types/quiz';
import { sampleQuestions } from '../data/sampleQuestions';
import { convertExcelDatesInText, convertExcelDatesInOptions } from '../utils/dateConverter';

// Function to create table if it doesn't exist
const createQuestionsTable = async () => {
  if (!supabase) return false;
  
  try {
    // Kh√¥ng th·ªÉ t·ª± ƒë·ªông t·∫°o b·∫£ng, ch·ªâ log warning
    console.warn('‚ö†Ô∏è B·∫£ng questions ch∆∞a t·ªìn t·∫°i. Vui l√≤ng t·∫°o b·∫£ng th·ªß c√¥ng trong Supabase SQL Editor.');
    return false;
  } catch (err) {
    console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ ki·ªÉm tra b·∫£ng questions:', err);
    return false;
  }
};

// Function to check if table exists
const checkTableExists = async () => {
  if (!supabase) return false;
  
  try {
    // Timeout cho table check
    const checkPromise = supabase
      .from('questions')
      .select('count', { count: 'exact', head: true });
    
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Table check timeout')), 5000);
    });
    
    const { error } = await Promise.race([checkPromise, timeoutPromise]) as any;
    
    if (error) {
      if (error.code === 'PGRST116' || error.message?.includes('Could not find the table')) {
        return false; // B·∫£ng kh√¥ng t·ªìn t·∫°i
      }
      if (error.message?.includes('timeout')) {
        console.warn('‚ö†Ô∏è Timeout khi ki·ªÉm tra b·∫£ng');
        return false;
      }
      // C√°c l·ªói kh√°c c√≥ th·ªÉ l√† do permission, coi nh∆∞ b·∫£ng t·ªìn t·∫°i
      return true;
    }
    
    return true; // B·∫£ng t·ªìn t·∫°i
  } catch (err) {
    console.warn('‚ö†Ô∏è L·ªói khi ki·ªÉm tra b·∫£ng:', err);
    return false;
  }
};

// Function to ensure table exists, create if needed
const ensureTableExists = async () => {
  const tableExists = await checkTableExists();
  if (!tableExists) {
    const created = await createQuestionsTable();
    if (created) {
      // Wait a moment for the table to be ready
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    return created;
  }
  return true;
};

export const useQuestions = () => {
  const [questions, setQuestions] = useState<Question[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [loadingTimeout, setLoadingTimeout] = useState<NodeJS.Timeout | null>(null);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (loadingTimeout) {
        clearTimeout(loadingTimeout);
      }
    };
  }, [loadingTimeout]);

  // Load questions from database (wrapped in useCallback to prevent infinite loops)
  const loadQuestions = useCallback(async () => {
    console.log('üîÑ loadQuestions: B·∫Øt ƒë·∫ßu t·∫£i c√¢u h·ªèi...');
    console.log('üîç Categories found:', [...new Set(questions.map(q => q.category))]);
    
    // N·∫øu ch∆∞a c·∫•u h√¨nh Supabase, kh√¥ng load ƒë∆∞·ª£c d·ªØ li·ªáu
    if (!isSupabaseConfigured() || !supabase) {
      console.log('‚ö†Ô∏è loadQuestions: Ch∆∞a c·∫•u h√¨nh Supabase');
      setQuestions([]);
      setLoading(false);
      setError('‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh Supabase. Vui l√≤ng c·∫•u h√¨nh ƒë·ªÉ s·ª≠ d·ª•ng.');
      return;
    }

    setLoading(true);
    setError(null);
    
    try {
      console.log('üîÑ loadQuestions: ƒêang ki·ªÉm tra b·∫£ng questions...');
      
      // Ki·ªÉm tra b·∫£ng c√≥ t·ªìn t·∫°i kh√¥ng v·ªõi timeout ng·∫Øn
      const tableExists = await Promise.race([
        checkTableExists(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 8000))
      ]).catch(err => {
        console.warn('‚ö†Ô∏è Timeout ho·∫∑c l·ªói khi ki·ªÉm tra b·∫£ng:', err);
        return false;
      });
      
      if (!tableExists) {
        console.warn('‚ùå loadQuestions: B·∫£ng questions ch∆∞a t·ªìn t·∫°i');
        setError('‚ùå B·∫£ng "questions" ch∆∞a t·ªìn t·∫°i trong database.\n\nüîß C√°ch kh·∫Øc ph·ª•c:\n1. V√†o Supabase Dashboard ‚Üí SQL Editor\n2. Copy script t·∫°o b·∫£ng t·ª´ h∆∞·ªõng d·∫´n\n3. Paste v√† click Run\n4. Refresh l·∫°i trang n√†y');
        setQuestions([]);
        setLoading(false);
        return;
      }
      
      console.log('üîÑ loadQuestions: ƒêang truy v·∫•n d·ªØ li·ªáu t·ª´ Supabase...');

      // Query v·ªõi timeout
      const countPromise = supabase
        .from('questions')
        .select('*', { count: 'exact', head: true });

      const { count: totalCount, error: countError } = await Promise.race([
        countPromise,
        new Promise((_, reject) => setTimeout(() => reject(new Error('Count timeout')), 5000))
      ]) as any;

      if (countError) {
        console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·∫øm t·ªïng s·ªë c√¢u h·ªèi:', countError);
      } else {
        console.log('üìä T·ªïng s·ªë c√¢u h·ªèi trong DB:', totalCount);
      }

      // Fetch t·∫•t c·∫£ d·ªØ li·ªáu b·∫±ng pagination
      let allData: any[] = [];
      const PAGE_SIZE = 1000;
      let currentPage = 0;
      let hasMore = true;

      while (hasMore) {
        const from = currentPage * PAGE_SIZE;
        const to = from + PAGE_SIZE - 1;

        console.log(`üîÑ ƒêang t·∫£i trang ${currentPage + 1} (t·ª´ ${from} ƒë·∫øn ${to})...`);

        const queryPromise = supabase
          .from('questions')
          .select('*')
          .range(from, to)
          .order('created_at', { ascending: false });

        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Query timeout')), 30000);
        });

        const { data: pageData, error: pageError } = await Promise.race([queryPromise, timeoutPromise]) as any;

        if (pageError) {
          console.error(`‚ùå L·ªói khi t·∫£i trang ${currentPage + 1}:`, pageError);
          throw pageError;
        }

        if (pageData && pageData.length > 0) {
          allData = [...allData, ...pageData];
          console.log(`‚úÖ ƒê√£ t·∫£i ${allData.length} c√¢u h·ªèi`);

          if (pageData.length < PAGE_SIZE) {
            hasMore = false;
          } else {
            currentPage++;
          }
        } else {
          hasMore = false;
        }
      }

      const data = allData;
      const error = null;

      console.log('üîÑ loadQuestions: K·∫øt qu·∫£ truy v·∫•n:', {
        dataLength: data?.length,
        totalCount: totalCount || 'unknown',
        pagesLoaded: currentPage + 1,
        status: 'Loaded all questions successfully'
      });

      if (error) {
        console.error('‚ùå loadQuestions: L·ªói t·ª´ Supabase:', error);
        
        if (error.message?.includes('timeout')) {
          setError('‚è±Ô∏è Timeout khi t·∫£i c√¢u h·ªèi. Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng.');
          setQuestions([]);
          setLoading(false);
          return;
        }

        if (error.code === 'PGRST116' || error.message?.includes('Could not find the table')) {
          setError('‚ùå B·∫£ng "questions" ch∆∞a t·ªìn t·∫°i.\n\nüîß ƒê·ªÉ s·ª≠a l·ªói n√†y:\n1. M·ªü Supabase Dashboard\n2. V√†o SQL Editor\n3. Ch·∫°y script t·∫°o b·∫£ng\n4. Refresh ·ª©ng d·ª•ng');
          setQuestions([]);
          setLoading(false);
          return;
        }
        
        throw error;
      }

      const formattedQuestions: Question[] = data.map(row => ({
        id: row.id,
        question: convertExcelDatesInText(row.question),
        options: convertExcelDatesInOptions(row.options),
        correctAnswer: row.correct_answer,
        explanation: convertExcelDatesInText(row.explanation || ''),
        category: row.category
      }));

      console.log('‚úÖ loadQuestions: ƒê√£ format th√†nh c√¥ng', formattedQuestions.length, 'c√¢u h·ªèi');
      setQuestions(formattedQuestions);
    } catch (err) {
      console.error('‚ùå loadQuestions: L·ªói kh√¥ng mong mu·ªën:', err);
      
      let errorMessage = 'L·ªói t·∫£i c√¢u h·ªèi';
      if (err instanceof Error) {
        if (err.message.includes('timeout')) {
          errorMessage = '‚è±Ô∏è K·∫øt n·ªëi ch·∫≠m. S·ª≠ d·ª•ng c√¢u h·ªèi m·∫´u.';
        } else if (err.message.includes('network') || err.message.includes('fetch')) {
          errorMessage = 'üåê L·ªói m·∫°ng. S·ª≠ d·ª•ng c√¢u h·ªèi m·∫´u.';
        } else {
          errorMessage = err.message;
        }
      }
      
      setError(errorMessage);
      // Kh√¥ng load ƒë∆∞·ª£c d·ªØ li·ªáu
      setQuestions([]);
    } finally {
      setLoading(false);
      console.log('‚úÖ loadQuestions: Ho√†n th√†nh');
    }
  }, []);

  // Save questions to database
  const saveQuestions = useCallback(async (newQuestions: Question[]) => {
    console.log('üîÑ saveQuestions: B·∫Øt ƒë·∫ßu l∆∞u', newQuestions.length, 'c√¢u h·ªèi');
    
    // N·∫øu ch∆∞a c·∫•u h√¨nh Supabase, ch·ªâ l∆∞u local
    if (!isSupabaseConfigured() || !supabase) {
      console.log('‚ö†Ô∏è saveQuestions: Ch∆∞a c·∫•u h√¨nh Supabase, l∆∞u local');
      setQuestions(newQuestions);
      setError('‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh Supabase. C√¢u h·ªèi ch·ªâ l∆∞u t·∫°m th·ªùi trong phi√™n l√†m vi·ªác n√†y.');
      return true;
    }

    setLoading(true);
    setError(null);

    try {
      console.log('üîÑ saveQuestions: ƒêang ki·ªÉm tra b·∫£ng...');
      
      // Ki·ªÉm tra b·∫£ng v·ªõi timeout
      const tableExists = await Promise.race([
        checkTableExists(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 5000))
      ]).catch(() => false);
      
      if (!tableExists) {
        setError('‚ùå Kh√¥ng th·ªÉ l∆∞u: Database ch∆∞a s·∫µn s√†ng.\n\nüõ†Ô∏è C·∫ßn l√†m:\n1. C·∫•u h√¨nh Supabase database\n2. T·∫°o b·∫£ng "questions"\n3. Th·ª≠ l·∫°i');
        return false;
      }
      
      // Convert to database format
      const dbQuestions = newQuestions.map(q => ({
        id: q.id,
        question: q.question,
        options: q.options,
        correct_answer: q.correctAnswer,
        explanation: q.explanation || null,
        category: q.category
      }));

      console.log('üîÑ saveQuestions: ƒêang x√≥a c√¢u h·ªèi c≈©...');
      
      // Clear existing questions v·ªõi timeout
      const deletePromise = supabase
        .from('questions')
        .delete()
        .neq('id', '');
      
      const { error: deleteError } = await Promise.race([
        deletePromise,
        new Promise((_, reject) => setTimeout(() => reject(new Error('Delete timeout')), 15000))
      ]) as any;

      if (deleteError) throw deleteError;

      console.log('üîÑ saveQuestions: ƒêang th√™m c√¢u h·ªèi m·ªõi...');

      const BATCH_SIZE = 100;
      let successCount = 0;
      const totalBatches = Math.ceil(dbQuestions.length / BATCH_SIZE);

      for (let i = 0; i < dbQuestions.length; i += BATCH_SIZE) {
        const batch = dbQuestions.slice(i, i + BATCH_SIZE);
        const batchNum = Math.floor(i / BATCH_SIZE) + 1;
        const progress = Math.round((successCount / dbQuestions.length) * 100);
        console.log(`üîÑ saveQuestions: Batch ${batchNum}/${totalBatches} (${batch.length} c√¢u) - ${progress}%`);

        const insertPromise = supabase
          .from('questions')
          .insert(batch);

        const { error: insertError } = await Promise.race([
          insertPromise,
          new Promise((_, reject) => setTimeout(() => reject(new Error('Insert timeout')), 120000))
        ]) as any;

        if (insertError) {
          if (insertError.code === 'PGRST116' || insertError.message?.includes('Could not find the table')) {
            setError('‚ùå B·∫£ng "questions" ch∆∞a t·ªìn t·∫°i. Vui l√≤ng t·∫°o b·∫£ng theo h∆∞·ªõng d·∫´n.');
            return false;
          }
          console.error(`‚ùå L·ªói batch ${batchNum}:`, insertError);
          throw insertError;
        }

        successCount += batch.length;
        console.log(`‚úÖ ƒê√£ l∆∞u ${successCount}/${dbQuestions.length} c√¢u (${progress}%)`);

        await new Promise(resolve => setTimeout(resolve, 100));
      }

      console.log('‚úÖ saveQuestions: L∆∞u th√†nh c√¥ng t·∫•t c·∫£', successCount, 'c√¢u h·ªèi');
      setQuestions(newQuestions);
      return true;
    } catch (err) {
      console.error('‚ùå saveQuestions: L·ªói:', err);
      
      let errorMessage = 'L·ªói l∆∞u c√¢u h·ªèi';
      if (err instanceof Error) {
        if (err.message.includes('timeout')) {
          errorMessage = '‚è±Ô∏è Timeout khi l∆∞u. Th·ª≠ l·∫°i sau.';
        } else {
          errorMessage = err.message;
        }
      }
      
      setError(errorMessage);
      return false;
    } finally {
      setLoading(false);
    }
  }, []);

  // Add questions (append to existing)
  const addQuestions = useCallback(async (newQuestions: Question[]) => {
    console.log('üîÑ addQuestions: B·∫Øt ƒë·∫ßu th√™m', newQuestions.length, 'c√¢u h·ªèi');

    // N·∫øu ch∆∞a c·∫•u h√¨nh Supabase, ch·ªâ th√™m local
    if (!isSupabaseConfigured() || !supabase) {
      console.log('‚ö†Ô∏è addQuestions: Ch∆∞a c·∫•u h√¨nh Supabase, th√™m local');
      setQuestions(prev => [...prev, ...newQuestions]);
      setError('‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh Supabase. C√¢u h·ªèi ch·ªâ l∆∞u t·∫°m th·ªùi trong phi√™n l√†m vi·ªác n√†y.');
      return true;
    }

    setLoading(true);
    setError(null);

    // Set timeout d√†i h∆°n cho vi·ªác import nhi·ªÅu c√¢u h·ªèi (15 ph√∫t)
    const timeout = setTimeout(() => {
      console.warn('‚ö†Ô∏è addQuestions: Timeout sau 15 ph√∫t');
      setLoading(false);
      setError('Timeout khi th√™m c√¢u h·ªèi. C√≥ th·ªÉ do s·ªë l∆∞·ª£ng c√¢u h·ªèi qu√° l·ªõn. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c chia nh·ªè file.');
    }, 900000);

    try {
      console.log('üîÑ addQuestions: ƒêang ki·ªÉm tra b·∫£ng...');
      // Ensure table exists first
      const tableExists = await ensureTableExists();
      if (!tableExists) {
        setError('‚ùå Kh√¥ng th·ªÉ th√™m c√¢u h·ªèi: B·∫£ng "questions" ch∆∞a t·ªìn t·∫°i.\n\nüìã H∆∞·ªõng d·∫´n t·∫°o b·∫£ng:\n1. Truy c·∫≠p Supabase Dashboard\n2. M·ªü SQL Editor\n3. Ch·∫°y script t·∫°o b·∫£ng questions\n4. Th·ª≠ upload l·∫°i');
        return false;
      }
      
      const dbQuestions = newQuestions.map(q => ({
        id: q.id,
        question: q.question,
        options: q.options,
        correct_answer: q.correctAnswer,
        explanation: q.explanation || null,
        category: q.category
      }));

      console.log('üîÑ addQuestions: ƒêang th√™m v√†o database...');

      // Gi·∫£m batch size ƒë·ªÉ import nhanh h∆°n v√† tr√°nh timeout
      const BATCH_SIZE = 50;
      let successCount = 0;
      const totalBatches = Math.ceil(dbQuestions.length / BATCH_SIZE);

      // Keepalive session m·ªói 100 batch
      let batchCounter = 0;

      for (let i = 0; i < dbQuestions.length; i += BATCH_SIZE) {
        const batch = dbQuestions.slice(i, i + BATCH_SIZE);
        const batchNum = Math.floor(i / BATCH_SIZE) + 1;
        const progress = Math.round((successCount / dbQuestions.length) * 100);
        console.log(`üîÑ addQuestions: Batch ${batchNum}/${totalBatches} (${batch.length} c√¢u) - ${progress}%`);

        const insertPromise = supabase
          .from('questions')
          .insert(batch);

        const { error } = await Promise.race([
          insertPromise,
          new Promise((_, reject) => setTimeout(() => reject(new Error('Insert timeout')), 60000))
        ]) as any;

        if (error) {
          if (error.code === 'PGRST116' || error.message.includes('Could not find the table')) {
            setError('‚ùå Upload th·∫•t b·∫°i: B·∫£ng "questions" ch∆∞a ƒë∆∞·ª£c t·∫°o.\n\n‚ö° Gi·∫£i ph√°p nhanh:\n1. Click n√∫t "H∆∞·ªõng d·∫´n" ƒë·ªÉ xem chi ti·∫øt\n2. T·∫°o b·∫£ng trong Supabase SQL Editor\n3. Upload l·∫°i file Excel');
            return false;
          }
          console.error(`‚ùå L·ªói batch ${batchNum}:`, error);
          throw error;
        }

        successCount += batch.length;
        console.log(`‚úÖ ƒê√£ th√™m ${successCount}/${dbQuestions.length} c√¢u (${progress}%)`);

        // Refresh session m·ªói 100 batch ƒë·ªÉ tr√°nh timeout
        batchCounter++;
        if (batchCounter % 100 === 0) {
          console.log('üîÑ Refreshing session...');
          await supabase.auth.refreshSession().catch(err => {
            console.warn('‚ö†Ô∏è Session refresh failed:', err);
          });
        }

        // Kh√¥ng delay ƒë·ªÉ import nhanh h∆°n
        // await new Promise(resolve => setTimeout(resolve, 100));
      }

      console.log('‚úÖ addQuestions: Th√™m th√†nh c√¥ng t·∫•t c·∫£', successCount, 'c√¢u h·ªèi');
      setQuestions(prev => [...prev, ...newQuestions]);
      clearTimeout(timeout);
      return true;
    } catch (err) {
      console.error('‚ùå addQuestions: L·ªói:', err);
      setError(err instanceof Error ? err.message : 'L·ªói th√™m c√¢u h·ªèi');
      clearTimeout(timeout);
      return false;
    } finally {
      setLoading(false);
    }
  }, []);

  // Delete all questions
  const clearQuestions = useCallback(async () => {
    console.log('üîÑ clearQuestions: B·∫Øt ƒë·∫ßu x√≥a t·∫•t c·∫£ c√¢u h·ªèi');
    
    // N·∫øu ch∆∞a c·∫•u h√¨nh Supabase, ch·ªâ x√≥a local
    if (!isSupabaseConfigured() || !supabase) {
      console.log('‚ö†Ô∏è clearQuestions: Ch∆∞a c·∫•u h√¨nh Supabase, x√≥a local');
      setQuestions([]);
      return true;
    }

    setLoading(true);
    setError(null);
    
    // Set timeout
    const timeout = setTimeout(() => {
      console.warn('‚ö†Ô∏è clearQuestions: Timeout sau 10 gi√¢y');
      setLoading(false);
      setError('Timeout khi x√≥a c√¢u h·ªèi. Vui l√≤ng th·ª≠ l·∫°i.');
    }, 10000);

    try {
      console.log('üîÑ clearQuestions: ƒêang ki·ªÉm tra b·∫£ng...');
      // Check if table exists, if not try to create it
      const tableExists = await checkTableExists();
      if (!tableExists) {
        const created = await createQuestionsTable();
        if (!created) {
          setError('‚ùå B·∫£ng "questions" ch∆∞a t·ªìn t·∫°i v√† kh√¥ng th·ªÉ t·ª± ƒë·ªông t·∫°o. Vui l√≤ng t·∫°o b·∫£ng th·ªß c√¥ng trong Supabase SQL Editor.');
          clearTimeout(timeout);
          return false;
        }
        // Wait a moment for the table to be ready
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      console.log('üîÑ clearQuestions: ƒêang x√≥a d·ªØ li·ªáu...');
      const { error } = await supabase
        .from('questions')
        .delete()
        .neq('id', ''); // Delete all

      if (error) {
        if (error.code === 'PGRST116' || error.message.includes('Could not find the table')) {
          setError('‚ùå B·∫£ng "questions" ch∆∞a t·ªìn t·∫°i. Vui l√≤ng t·∫°o b·∫£ng trong Supabase SQL Editor theo h∆∞·ªõng d·∫´n.');
          clearTimeout(timeout);
          return false;
        }
        throw error;
      }

      console.log('‚úÖ clearQuestions: X√≥a th√†nh c√¥ng');
      setQuestions([]);
      clearTimeout(timeout);
      return true;
    } catch (err) {
      console.error('‚ùå clearQuestions: L·ªói:', err);
      setError(err instanceof Error ? err.message : 'L·ªói x√≥a c√¢u h·ªèi');
      clearTimeout(timeout);
      return false;
    } finally {
      setLoading(false);
    }
  }, []);

  // Load questions on mount
  useEffect(() => {
    console.log('üîÑ useQuestions: Component mounted, b·∫Øt ƒë·∫ßu load questions');
    loadQuestions();
  }, []);

  return {
    questions,
    loading,
    error,
    isSupabaseConfigured: isSupabaseConfigured(),
    loadQuestions,
    saveQuestions,
    addQuestions,
    clearQuestions
  };
};